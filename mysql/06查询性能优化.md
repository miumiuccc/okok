
查询性能优化

6.1 为什么查询速度会慢
在每一个消耗大量时间的查询案例中,我们都能看到一些不必要的额外操作,某些操作被额外地重复了很多次,某些操作执行得太慢等等.
优化查询的目的就是减少和消除这些操作所花费的时间.

6.2 慢查询基础:优化数据访问
对于低效的查询,我们发现通过下面两个步骤来分析总是很有效:
1.确认应用程序是否在检索大量超过需要的数据.这通常意味着访问了太多的行,但有时候也可能是访问了太多的列.
2.确认MySQL服务器层是否在分析大量超过需要的数据行.

6.2.1 是否先数据库请求了不需要的数据
一些错误的案例情况:
1.查询不需要的记录(解决:查询加上limit)
2.多表关联时返回全部列
3.总是取出全部列(一些DBA是严格禁止select * 的写法的)
4.重复查询相同的数据.


6.2.2 是否扫描额外的记录
在确定查询只返回需要的数据之后,接下来应该看看查询为了返回结果,是否扫描了过多的数据.对于MySQL,最简单的衡量查询开销的三个指标如下:
1.响应时间:包括两个部分之和:服务时间和排队时间
2.扫描的行数:扫面的行数和返回的行数的比率通常很小,一般在1:1和10:1之间,不过有时候这个值也可能非常非常大.
3.返回的行数
在EXPLAIN语句中的type列反应了访问类型.访问类型有很多种:(全表扫面,索引扫描,范围扫描,唯一索引查询,常数应用)等.这里列的这些,速度是从慢到快,扫描的行数也是从小到大.
eg.  EXPLAIN select * from sakila.film_actor where film_id = 1;

如果发现查询需要扫描大量的数据,但只返回少数的行,那么通常可以尝试下面的技巧去优化它:
1.使用索引覆盖扫描,把所有需要用的列都放到索引中,这样存储引擎无须回表获取对应行就可以返回结果.
2.改变库表结构,例如使用单独的汇总表
3.重写这个复杂的查询,让MySQL优化器能够以更优化的方式执行这个查询.

这三个指标都会记录在MySQL的慢日志中,所以检查慢日志记录是找出扫描行数过多的查询的好办法.


6.3 重构查询的方式
6.3.1 一个复杂查询还是多个简单查询
在传统实现总,总是强调需要数据库层完成尽可能多的工作,这样做的逻辑在于以前总是认为网络通信,查询解析和优化是一件代价很高的事情.
但是这样的想法对于MySQL并不适用,MySQL从设计上让链接和断开连接都很轻量级,在返回一个小的查询结果方面很高效.

MySQL内部美妙能够扫描内存中上百万行数据,相比之下,MySQL响应数据给客户端就慢很多.

6.3.2 切分查询
场景:删除旧数据.
定期清除大量数据时,如果用一个大的语句一次性完成的话,则可能需要一次锁住很多数据,占满整个事务日志,耗尽系统资源,阻塞很多小的但重要的查询
将一个大的delete语句切分成多个小的查询可以尽可能小影响MySQL性能,同时还可以减少MySQL复制的延迟.
例如:每月运行一次下面的查询:
delete from message where create < DATE_SUB(NOW(),INTERVAL 3 MONTH);
优化:用下面方式,完成同样的工作
rows_affected = 0
do {
	rows_affected = do_query(
		"delete from message where create < DATE_SUB(NOW(),INTERVAL 3 MONTH)
		limit 10000")
   } while rows_affected > 0

可以定时执行,分散执行,缓解其他重要查询的压力.


6.3.3 分解关联查询
很多高性能的应用都会对关联查询进行分解.简单地,可以对每一个表进行一次单标查询,然后将结果在应用中进行关联.
例如:下面这个查询
select * from tag 
join tag_post on tag_post.tag_id = tag.id 
join post on tag_post.post_id = post.id
where tag.tag = 'mysql';

分解优化:
select * from tag where tag = 'mysql';
select * from tag_post where tag_id = 1234;
select * from post where post.id in (123,456,567);

这样分解的优势:
1.让缓存的效率更高.许多应用程序可以方便地缓存单表查询对应的结果对象.
2.将查询分解后,执行单个查询可以减少锁的竞争.
3.在应用层做关联,可以更容易对数据库进行拆分,更容易做到高性能和可扩展.
4.查询本身效率也可能会有所提升
5.可以减少冗余记录的查询
6.更进一步,这样做相当于在应用中实现了哈希关联,而不是使用MySQL的嵌套循环关联.

6.4 查询执行的基础
MySQL执行一个查询的过程:
1.客户端发送一条查询给服务器.
2.服务器先检查查询缓存,如果命中了缓存,则立刻返回存储在缓存中的结果.否则进入下一个阶段.
3.服务器端进行SQL解析,预处理,再由优化器生成对应的执行计划.
4.MySQL根据优化器生成的执行计划,调用存储引擎的API来执行查询.
5.将结果返回给客户端.

6.4.1 MySQL客户端 / 服务器通信协议
查询状态语句:show full processlist;
一些状态:
Sleep							//线程正在等待客户端发送行的请求
Query							//线程正在执行查询或者正在将结果发送给客户端
Locked							//在MySQL服务器层,该线程正在等待表锁
Analyzing and statistics		//线程正在收集存储引擎的统计信息,并生成查询的执行计划
Copying to tmp table [on disk]	//线程正在执行查询,并且将其结果集复制到一个临时表总(这种状态一般要么是group by 要么是union)
Sorting result					//线程正在对结果集进行排序
Sending data					//这表示多种情况:线程可能在多个状态之间传送数据,或者在生成结果集,或者在向客户端返回数据.

6.4.2 查询缓存
6.4.3 查询优化处理
6.4.4 查询执行引擎
6.4.5 返回结果给客户端


6.5 MySQL 查询优化器的局限性
6.5.1 关联子查询
因为使用in()加子查询,性能经常会非常糟,所以通常建议使用exists()等效的改写查询来获取更好的效率
eg. select * from sakila.film where exists( select * from sakila.film_actor where actor_id = 1);
6.5.2 UNION 的限制
6.5.3 索引合并优化
6.5.4 等值传递
6.5.5 合并执行
MySQL无法利用多核特性来并行执行查询.
6.5.6 哈希关联
MySQL不支持哈希关联.
6.5.7 松散索引扫描
6.5.8 最大值和最小值优化
对于MIN()和MAX()查询,MySQL的优化做的并不好,下面例子:(例子中actor_id是表主键)
select MIN(actor_id) from sakila.actor where first_name = 'PENELOPE';
上面语句会执行全表扫描
优化:
select actor from sakila.actor user index(primary) where first_name = 'PENELOPE' limit 1;


6.5.9 在同一个表上查询和更新

6.6 查询优化器的提示(hint)

6.7优化特定类型的查询
6.7.1 优化COUNT()查询
6.7.2 优化关联查询
6.7.3 优化子查询
6.7.4 优化GROUP BY 和 DISTINCT
6.7.5 优化LIMIT分页
6.7.6 优化SQL_CALC_FOUND_ROWS
6.7.7 优化UNION查询
6.7.8 静态查询分析
6.7.9 使用用户自定义变量

6.8 案例学习
6.8.1 使用MySQL构建一个队列表
6.8.2 计算两点之间的距离
6.8.3 使用用户自定义函数

看到269页